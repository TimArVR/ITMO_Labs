
    //const int kNum_of_elems = 32;
    //const int kNum_of_tests = 100;
    //LARGE_INTEGER Start;
    //LARGE_INTEGER End;
    //LARGE_INTEGER Delta;
    //LARGE_INTEGER Freq;
    //double elapse = 0;
    //double sum_of_IS = 0;
    //double sum_of_QS = 0;
    //std::ofstream fileout("savedata.csv");
    //fileout << "Size" << ","<<"IS"<<","<<"QS\n";

    //QueryPerformanceFrequency(&Freq);

    //for (int i = 3; i < kNum_of_elems; i++)    {

    //    for (int k = 0; k < kNum_of_tests; k++)
    //    {
    //        int* arr_IS = new int[i];
    //        int* arr_QS = new int[i];

    //        for (int j = 0; j < i; j++)
    //        {
    //            arr_IS[j] = i - j;
    //            arr_QS[j] = rand()%100;
    //        }

    //        QueryPerformanceCounter(&Start);

    //        InsertionSort(arr_IS, arr_IS + i - 1, [](int a, int b) {return a < b; });

    //        QueryPerformanceCounter(&End);


    //        Delta.QuadPart = End.QuadPart - Start.QuadPart; //считаем дельту

    //        elapse = double(Delta.QuadPart * 1000000) / Freq.QuadPart;

    //        sum_of_IS += elapse;


    //        QueryPerformanceCounter(&Start);

    //        QuickSort(arr_QS, arr_QS + i - 1, [](int a, int b) {return a < b; });

    //        QueryPerformanceCounter(&End);

    //        Delta.QuadPart = End.QuadPart - Start.QuadPart; //считаем дельту

    //        elapse = double(Delta.QuadPart * 1000000) / Freq.QuadPart;

    //        sum_of_QS += elapse;

    //        delete[] arr_IS;
    //        delete[] arr_QS;

    //    }

    //    fileout << i << "," << sum_of_IS / kNum_of_tests << "," << sum_of_QS / kNum_of_tests << "\n";
    //}

    //fileout.close();



    ////////////////////////////////////////////////////